# 1. 装饰器
## 1.1 概念
* 装饰器是一种特殊类型的声明，它能够被附加到```类声明```，```方法```， ```访问符```，```属性```或```参数```上。
* 装饰器使用 ```@expression```这种形式，```expression```求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。

## 1.2 分类
## 1.2.1 类装饰器
* 类装饰器在类声明之前被声明（紧靠着类声明）。
* 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。
* 类装饰器不能用在声明文件中( .d.ts)，也不能用在任何外部上下文中（比如declare的类）。
* 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。
  ```js
  function sealed(constructor: Function) { // 装饰器
    Object.seal(constructor);
    Object.seal(constructor.prototype);
  }

  @sealed // 应用
  class Greeter {
      greeting: string;
      constructor(message: string) {
          this.greeting = message;
      }
      greet() {
          return "Hello, " + this.greeting;
      }
  }
    ```
* 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。
  ```js
  function classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
    }
  }

  @classDecorator
  class Greeter {
      property = "property";
      hello: string;
      constructor(m: string) {
          this.hello = m;
      }
  }

  console.log(new Greeter("world"));
  ```
### 1.2.2 属性装饰器
* 属性装饰器声明在一个属性声明之前（紧靠着属性声明）。
* 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。
* 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：
  * 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
  * 成员的名字。
  ```js
  import "reflect-metadata";

  const formatMetadataKey = Symbol("format");

  function format(formatString: string) {
      return Reflect.metadata(formatMetadataKey, formatString);
  }

  function getFormat(target: any, propertyKey: string) {
      return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
  }
  class Greeter {
    @format("Hello, %s")
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        let formatString = getFormat(this, "greeting");
        return formatString.replace("%s", this.greeting);
    }
  }
  ```
## 1.3 补充
### 1.3.1 装饰器工厂
*  装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。
* 例子：
  ```js
    function color(value: string) { // 这是一个装饰器工厂
      return function (target) { //  这是装饰器
          // do something with "target" and "value"...
      }
    }
  ```
### 1.3.2 装饰器求值
* 类中不同声明上的装饰器将按以下规定的顺序应用：
  * 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。
  * 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。
  * 参数装饰器应用到构造函数。
  * 类装饰器应用到类。
