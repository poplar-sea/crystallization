# 1.泛型
* 作用：使返回值的类型与传入参数的类型是相同的。
## 1.1 泛型变量
```js
// 定义泛型函数
function identity<T>(arg: T): T {
    return arg;
}
// 使用泛型函数：第一种是，传入所有的参数，包含类型参数
let output = identity<string>("myString");  // type of output will be 'string'
// 使用泛型函数：利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型
let output = identity("myString");  // type of output will be 'string'
```
* 类型变量```T```帮助我们捕获用户传入的类型（比如：string），之后我们就可以使用这个类型；
* 使用```<>```括起来，参数传给类型变量,这时T是string类型；

# 1.2 泛型函数类型
* 使用方式1：使用相同的泛型参数名
```ts
function identity<T>(arg: T): T {
    return arg;
}:
let myIdentity: <T>(arg: T) => T = identity;
```
* 使用方式2：使用不同的泛型参数名
```ts
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: <U>(arg: U) => U = identity;
```
* 使用方式3：使用带有调用签名的对象字面量来定义泛型函数
```ts
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: {<T>(arg: T): T} = identity;
```

# 1.3 泛型接口
* 接口内部使用泛型
```ts
interface GenericIdentityFn {
    <T>(arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
```
* 接口接受泛型参数
```ts
interface GenericIdentityFn<T> {
    (arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;
```