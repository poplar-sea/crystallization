# 1. typeof
```js
// 1.typeof
console.log(typeof 2)              // number
console.log(typeof '2')            // string
console.log(typeof true)           // boolean
console.log(typeof undefined)      // undefined
console.log(typeof Symbol())       // symbol
console.log(typeof function(){})   // function
console.log(typeof {})             // object
console.log(typeof [])             // object
console.log(typeof null)           // object
```
* 数组、对象、null 都会被判断为 object，其他判断都正确。
* 表达式```void *``` 没有返回值，因此返回结果是 undefined。
# 2. instanceof
```js
console.log(2 instanceof Number)                // false
console.log('2' instanceof String)              // false
console.log(true instanceof Boolean)            // false
console.log([] instanceof Array)                // true
console.log({} instanceof Object)               // true
console.log(function(){} instanceof Function)   // true
```
* instanceof 只能正确判断引用数据类型，而不能判断基本数据类型
* instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。
# 3. constructor
```js
// 3.constructor
console.log((2).constructor === Number)                // true
console.log('2'.constructor === String)                // true
console.log((true).constructor === Boolean)            // true
console.log([].constructor === Array)                  // true
console.log({}.constructor === Object)                 // true
console.log((function(){}).constructor === Function)   // true
```
* constructor 有两个作用:
  * 一是判断数据的类型
  * 二是对象实例通过constrcutor 对象访问它的构造函数
* 如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型
# 4. Object.prototype.toString.call()
```js
var a = Object.prototype.toString
console.log(a.call(2))              // [object Number]
console.log(a.call('2'))            // [object String]
console.log(a.call(true))           // [object Boolean]
console.log(a.call(undefined))      // [object Undefined]
console.log(a.call(Symbol()))       // [object Symbol]
console.log(a.call(function(){}))   // [object Function]
console.log(a.call({}))             // [object Object]
console.log(a.call([]))             // [object Array]
console.log(a.call(null))           // [object Null]
```
# 5. intanceof 操作符的实现原理及实现
```js
function myInstanceof(left, right) {
    // 1.获取对象的原型
    let proto = Object.getPrototypeOf(left)
    // 2.获取构造函数的prototype
    let prototype = right.prototype
    // 3.判断构造函数的prototype对象是否在对象的原型链上
    while(true) {
        if(!proto) return false
        if(proto === prototype) return true
        proto = Object.getPrototypeOf(proto)
    }
}
console.log(myInstanceof(2, Number))  // true
console.log(myInstanceof({}, Object)) // true
```