# 1. type的用法
```go
// 1. 第一种 给一个类型定义别名,这种别名实际上是为了代码的可读性
type myByte = byte // 这个类型本质上仍然是uint8，无非就是在代码编码阶段可读性强而已

// 2. 第二种 基于一个已有的类型定义一个新的类型
type myInt int

// 3. 第三种 定义结构体
type Course struct {
  name string
  price int
}
// 4. 第四种 定义接口
type Callabel interface {

}
// 5. 第五种 定义函数别名
type handle func(str string)
```

# 2. defer的用法
* defer 的执行顺序是后进先出；

# 3. panic 的用法
* 在Go语言中，panic是一个内置函数，用于表示程序出现了不可恢复的错误。当panic函数被调用时，程序会立即停止当前流程并抛出一个错误，然后终止运行。
* 当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic

# 4. recover 的用法
* 在匿名函数中，使用recover()函数捕获panic错误，并打印出错误消息。这样就可以在发生panic时恢复程序并继续执行后续代码。

# 5. range
* 当使用Go语言中的range关键字时，它用于迭代```数组```、```切片```、```映射```和```通道```等集合类型的数据。range可以返回每个元素的```索引```和```值```，或者仅返回索引（对于通道）。

# 6. append 
* 能对指针执行 append 操作；
* append() 的第二个参数不能直接使用 slice，需使用 … 操作符
  * ```go
    s1 := []int{1, 2, 3}
    s2 := []int{4, 5}
    append(s1,s2…)
    ```
# 7. make
* make只能为```slice```, ```map```, ```channel```分配内存，并返回一个初始化的值
* 返回的类型就是这三个类型本身，而不是他们的指针类型
* ```go
  // 1.slice
  a := make([]int, 200, 300) // len=200, cap=300的切片  
  b := make([]int, 200)     // cap=len=200的切片  
  c := make([]int, 200, 200)// c == b
  // 2.map
  a := make(map[int]string) // map的初始值，空map
  // 3.channel
  ch := make(chan int, 10)  // 可读可写且带缓存区
  ```
# 8. new
* 在Go语言中，new是一个关键字，用于在堆上分配内存并将其初始化为```零值```。
* 在Go语言中，new关键字返回的是一个变量类型对应的```指针类型```
* 可以用于创建用户自定义类型的实例。
* new关键字的语法为：```ptr := new(Type)```，其中```Type```表示要创建的```对象的类型```，```ptr```是指向```新对象的指针```。

# 9. const
* 使用const关键字定义常量
```go
// 定义单个常量
const PI float64 = 3.1415926
// 定义多个常量
const (
  PI       float64 = 3.1415926
  MaxAge   int     = 150
  Greeting string  = "hello world"
) 
```
* 建议将相同类型的，相关联的常量定义在一个组里面
* 隐式重复前一个非空表达式的机制
* 限制： 
  * 只能定义基本类型的常量，即布尔类型（bool），整数（无符号uint/uint8/uint16/uint32/uint64/uintptr，有符号int/int8/int16/int32/int64），浮点数（单精度float32，双精度float64），或者底层类型是这些基本类型的类型。
  * 不能定义切片，数组，指针，结构体等这些类型的常量
* 
# 10.iota
* iota 是Go语言的一个预定义标识符，表示const声明块(包括单行声明)中每个常量所处位置在块中的偏移值(从零开始),即iota的值等于它出现在常量定义组的第几行
