# 1.Go 语言数据类型
## 1.1数据类型的作用
* 在 Go 编程语言中，数据类型用于声明函数和变量。
* 数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存
* 数据类型：布尔型、数字类型、字符串类型、派生类型
## 1.2 数字类型
### 1.2.1 整型
|  序号   | 类型和描述  |
|  ----  | ----  |
| 1  | uint8: 无符号```8``` 位整型 (0 到 255) |
| 2  | uint16: 无符号 ```16``` 位整型 (0 到 65535) |
| 3 | uint32: 无符号 ```32``` 位整型 (0 到 4294967295) |
| 4 | uint64: 无符号 64 位整型 (0 到 18446744073709551615) |
| 5  | int8: 有符号 ```8``` 位整型 (-128 到 127) |
| 6  | int16: 有符号 ```16``` 位整型 (-32768 到 32767) |
| 7  | int32: 有符号 ```32``` 位整型 (-2147483648 到 2147483647) |
| 8  | int64: 有符号 ```64``` 位整型 (-9223372036854775808 到 9223372036854775807) |
### 1.2.2 浮点型
|  序号   | 类型和描述  |
|  ----  | ----  |
| 1 |float32: EEE-754 32位浮点型数 |
| 2  | float64: EEE-754 64位浮点型数 | |
| 3  | complex64: 32 位实数和虚数 |
| 4  | complex128: 64 位实数和虚数 |

### 1.2.3 其他数字类型
|  序号   | 类型和描述  |
|  ----  | ----  |
| 1  | byte: 类似 uint8 |
| 2  | rune: 类似 int32 |
| 3  | uint: 32 或 64 位 |
| 4  | int: 与 uint 一样大小 |
| 5  | uintptr: 无符号整型，用于存放一个指针 |

## 1.3 布尔类型
布尔型的值只可以是常量 ```true``` 或者 ```false```。

## 1.4 字符串类型
* 字符串就是一串固定长度的字符连接起来的字符序列。
* ```Go``` 的字符串是由单个字节连接起来的。
* ```Go``` 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。
## 1.5 派生类型
### 1.5.1 函数类型
* 数据格式:
``` go
func function_name( [parameter list] ) [return_types] {
   函数体
}
/**
func：函数由 func 开始声明
function_name：函数名称，参数列表和返回值类型构成了函数签名。
parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。
return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。
函数体：函数定义的代码集合。
*/
```
### 1.5.2 数组类型
```go
// 语法格式
var variable_name [SIZE] variable_type
// 声明数组
var balance [10] float32
// 初始化数组
var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
// 不定长数组
var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
或
balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
// 初始化部分数组
balance := [5]float32{1:2.0,3:7.0} //  将索引为 1 和 3 的元素初始化
```
### 1.5.3 指针类型(Pointer)
* 什么是指针
  * 一个指针变量指向了一个值的内存地址。
  * 指针声明格式如下：```var var_name *var-type ```
* 如何使用指针:
```go
package main

import "fmt"

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &a  /* 指针变量的存储地址 */

   fmt.Printf("a 变量的地址是: %x\n", &a  )

   /* 指针变量的存储地址 */
   fmt.Printf("ip 变量储存的指针地址: %x\n", ip )

   /* 使用指针访问值 */
   fmt.Printf("*ip 变量的值: %d\n", *ip )
}
```
* 空指针：当一个指针被定义后没有分配到任何变量时，它的值为 ```nil```。
#### 1.5.3.1 指针操作符
* ```&``` 取地址操作符 取出地址
* ```*``` 取值操作符   根据地址取出地址指向的值
#### 1.5.3.2 变量、指针地址、指针变量、取地址、取值的相互关系
* 对变量进行取地址(&)，可以获得这个变量的指针变量；
* 指针变量的值是指针地址。
* 对指针变量进行取值(*)操作，可以获得指针变量指向原变量的值。
#### 1.5.3.4 创建指针的方法
* 方式1：
  * ```go
    ptr := &v // v的类型为T
    ```
* 方式2：```new()```函数
  * ```go
    str := new(string)
    ```
### 1.5.4 结构体类型(struct)
* 定义：结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。
* 格式：
    ```
    type struct_variable_type struct {
      member definition
      member definition
      ...
      member definition
    }
    ```

* 声明变量：
  ```
  variable_name := structure_variable_type {value1, value2...valuen}
  或
  variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}
  ```
### 1.5.5 接口类型(interface)
* ```interface{}```类型的变量可以存储任何类型的值，包括基本类型、结构体类型、数组类型等。
### 1.5.6 Channel类型
### 1.5.7 切片类型

### 1.5.8 Map类型

## 1.6 类型断言
### 1.6.1 介绍
* 类型断言是一种检查接口类型变量的值是否实现了期望的接口或者具体的类型的操作。
### 1.6.2 语法格式
```go
val, ok := x.(T)
// x是一个接口类型的变量，T是一个期望的类型
// 如果x的实际类型是T或T的子类型，则ok的值为true，否则为false
```
### 1.6.3 案例
```go
var i interface{} = 42
if num, ok := i.(int); ok {
    fmt.Println("i is an int", num)
} else {
    fmt.Println("i is not an int")
}
// 首先将i声明为一个interface{}类型的变量，并将其赋值为42
// 然后使用类型断言来检查i是否是一个int类型的变量
// 42是一个int类型的值，因此类型断言成功，并将num赋值为42
// 最后，我们打印出num的值。
```
### 1.7 内置式原生类型的默认值
* 所有整型类型: 0
* 浮点类型: 0.0
* 布尔类型: false
* 字符串类型: ""
* 指针、inferface、切片(slice)、channel、map、function: nil
* 数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化