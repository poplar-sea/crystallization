# 1. js模拟树结构
```js
let node = {
    val: 'A',
    left: {
        val: 'B',
        left: {
            val:'D',
        },
        right: {
            val:'E',
        },
    },
    right: {
        val:'C',
        left:null,
        right:{
            val:'F'
        },
    }
    }
```
# 2. 二叉树的遍历
## 2.1 前序遍历
* 前序遍历就是先访问根节点，然后递归地遍历左子树，最后递归地遍历右子树。
```js
function preorderTraversal(node) {
    if (!node) return[]

    let res = []
    res.push(node.val);// 先将根节点push到数组中
    let L=preorderTraversal(node.left); // 遍历左子树
    let r=preorderTraversal(node.right); // 遍历右子树
    return res.concat(L).concat(r)//拼接
}
console.log(preorderTraversal(node));
```
## 2.2 中序遍历
* 中序遍历就是先递归地遍历左子树，然后访问根节点，最后递归地遍历右子树。
```js
function preorderTraversal(node) {
    if (!node) return[]
    let res = []
    
    let L=preorderTraversal(node.left); // 遍历左子树
    res.push(node.val);// 将根节点push到数组中
    let r=preorderTraversal(node.right); // 遍历右子树
    return L.concat(res).concat(r)
}
console.log(preorderTraversal(node));

```
## 2.3 后序遍历
* 后序遍历就是先递归地遍历左子树，然后递归地遍历右子树，最后访问根节点。
```js
function preorderTraversal(node) {
    if (!node) return[]
    let res = []
    
    let L=preorderTraversal(node.left); // 遍历左子树
    let r=preorderTraversal(node.right); // 遍历右子树
    res.push(node.val);// 先访问根节点
    return L.concat(r).concat(res)
}
console.log(preorderTraversal(node));

```